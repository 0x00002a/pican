use std::path::Path;

use glob::glob;

fn mk_test(prog_file: &Path) -> String {
    format!(
        r#"
#[test]
fn {name}() {{
    let mut ctx = PicanContext::new();
    let input_id = ctx.add_file(
        "{path}",
        std::fs::read_to_string("{path}").expect("failed to read input"),
    );

    let pir_ctx = IrContext::new();
    let pir = pican_frontend::parse_and_lower(input_id, &ctx, &pir_ctx);
    if pir.is_none() {{
        super::print_diagnostics(&ctx.diag.as_codespan(), &ctx.files);
    }}
    assert!(pir.is_some());
}}
"#,
        path = prog_file.display(),
        name = prog_file
            .file_stem()
            .unwrap()
            .to_string_lossy()
            .replace([' '], "_space_")
            .replace('-', "_dash_")
            .replace('.', "_dot_"),
    )
}

fn main() {
    let test_root = Path::new("./src");
    let output_file = test_root.join("all_programs_compile.rs");
    let programs = glob("inputs/*.pica").expect("failed to read glob");
    println!("cargo:rerun-if-changed=../inputs");
    let cases = programs
        .map(|p| p.expect("failed to get path to program file"))
        .map(|p| mk_test(&p))
        .collect::<Vec<_>>()
        .join("\n");
    std::fs::write(
        output_file,
        format!(
            r#"
//! This file is automatically generated as part of the build, do not edit it by hand
use pican_core::context::{{PicanContext, IrContext}};

{cases}
    "#
        ),
    )
    .expect("failed to write out programs");
}
